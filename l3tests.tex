\documentclass{article}

\ExplSyntaxOn

% TODO tmp vars > clear_new


\keys_define:nn { non-decimal-units }
{
	replace~nil~with 			.tl_set:N		= \l_ndu_replace_nil_with_tl ,
	treat~zero~as~nil 			.bool_set:N 	= \l_ndu_treat_zero_as_nil_bool ,
	treat~zero~as~nil 			.default:n 		= true ,
	segment~separator 			.tl_set:N		= \l_ndu_segment_separator_tl ,
	segment~separator			.default:n		= { ~ } ,
	default~format				.tl_set:N		= \l_ndu_default_format_tl ,
	default~format				.default:n		= { \VALUE\ \SYMBOL } ,
	normalize 					.bool_set:N		= \l_ndu_normalize_bool ,
	normalize 					.default:n 		= true ,
	aligned						.bool_set:N		= \l_ndu_aligned_bool ,
	aligned						.default:n 		= true ,
	cell~width					.dim_set:N		= \l_ndu_cell_width_dim ,
	cell~width 					.default:n 		= 3em ,
	display						.choice: ,
	display						.choices:nn		= 
		{ values~only, symbols~only, formatted }
		{ \tl_set_eq:NN \l_ndu_display_choice_tl \l_keys_choice_tl } ,
	display						.default:n		= { formatted } ,
	current~variable			.tl_set:N		= \l_ndu_current_variable_tl ,
	current~operator			.tl_set:N		= \l_ndu_current_operator_tl ,
	add~to~variable				.meta:n			= {
			current~variable = {#1} ,
			current~operator = {+}
		} ,
	subtract~from~variable		.meta:n			= {
			current~variable = {#1} ,
			current~operator = {-}
		} ,
	set aligned for environment	.code			= {
		\AtBeginEnvironment{#1}{\nduKeys{aligned}}
	},
}

\keys_set:nn { non-decimal-units } {
	segment~separator,
	default~format,
	display,
%	set aligned for environment=tabular,
}

\NewDocumentCommand { \nduKeys } { m } {
	\keys_set:nn { non-decimal-units } { #1 }
}


\NewDocumentCommand { \nduNewUnitGroup } { m m m o o }
{
	\seq_set_from_clist:cn { l_ndu_group_#1_seq } {#2}

	% set base unit to rightmost item
	\seq_get_right:cN { l_ndu_group_#1_seq } \l_tmpa_tl
	\tl_set_eq:cN { l_ndu_base_unit_#1_tl } \l_tmpa_tl

	% create keys for the units
	\seq_map_inline:cn { l_ndu_group_#1_seq } {
		\keys_define:nn { non-decimal-units / units / ##1 } {
			factor				.int_set:c		= { l_ndu_factor_##1_ \tl_use:c { l_ndu_base_unit_#1_tl } _int } ,
			symbol				.tl_set:c		= { l_ndu_symbol_##1_tl } ,
			format				.tl_set:c		= { l_ndu_format_##1_tl } ,
		}
	}

	% set the unit keys
	\keys_set:nn { non-decimal-units / units } { #3 }

	\IfValueT {#4} {
		\NewDocumentCommand { #4 } { O{} m } {
			\group_begin:
			\IfValueTF {#5} {
				\nduValue{#1}[#5,##1]{##2}
			}
			{
				\nduValue{#1}[##1]{##2}
			}
			\group_end:
		}
	}
}


\nduNewUnitGroup { danish~rigsdaler } {
	rigsdaler ,
	mark ,
	skilling ,
	hvid
}{
	rigsdaler / factor = 288 ,
	rigsdaler / symbol = { Rdl. } ,
%	rigsdaler / format = { \SYMBOL\ \VALUE } ,
	mark / factor = 48 ,
	mark / symbol = { Mk. } ,
	skilling / factor = 3 ,
	skilling / symbol = { Sk. } ,
	hvid / factor = 1 ,
	hvid / symbol = { Hv. } ,
}[\rdl]


\int_new:N \l__ndu_tmpa_int
\int_new:N \l__ndu_tmpb_int
\int_new:N \l__ndu_tmpc_int
\int_new:N \l__ndu_tmpd_int

\tl_new:N \l__ndu_tmpa_tl
\tl_new:N \l__ndu_tmpb_tl
\tl_new:N \l__ndu_tmpc_tl
\tl_new:N \l__ndu_tmpd_tl




\cs_new_protected:Nn \ndu_repr_to_seq:NNNNN
{
	% parameters
	% #1: output result (seq)
	% #2: unit sequence (seq)
	% #3: base unit (tl)
	% #4: amount (int)
	% #5: unit (tl)
	% scratch vars:
	\seq_clear:N #1
	% \l__ndu_tmpa_int: remaining amount
	% \l__ndu_tmpb_int: current factor
	% \l__ndu_tmpc_int: current amount of that factor
	% \l__ndu_tmpd_int: loop index

	% initial amount * base factor
	\int_set:Nn \l__ndu_tmpa_int { #4 * \int_use:c { l_ndu_factor_#5_ \tl_use:N {#3} _int } }

	% for i, (name, factor) in enumerate(units):
	\seq_map_inline:Nn #2
	{
		\int_set:Nn \l__ndu_tmpb_int { \int_use:c { l_ndu_factor_##1_ \tl_use:N {#3} _int } }
		\int_set:Nn \l__ndu_tmpc_int 0

		% while (amount >= factor):
		\int_while_do:nn {\l__ndu_tmpa_int >= \l__ndu_tmpb_int} {
			% amount -= factor
			\int_sub:Nn \l__ndu_tmpa_int \l__ndu_tmpb_int
			% result[i] += 1
			\int_incr:N \l__ndu_tmpc_int
		}
		\seq_put_right:Nx #1 {\int_use:N \l__ndu_tmpc_int}
		
		% stop when we hit the desired unit depth
		\str_if_eq:NNT {##1} {#5} {
			\seq_map_break:
		}
	}
}
\cs_generate_variant:Nn \ndu_repr_to_seq:NNNNN {
	NccNc,
	Ncccc
}



\cs_new_protected:Nn \ndu_seq_to_repr:NNNN
{
	% parameters
	% #1: output result (int)
	% #2: unit sequence (seq)
	% #3: base unit (tl)
	% #4: input (seq)
	% scratch vars
	% \l__ndu_tmpa_tl: current amount
	\int_zero:N #1

	\seq_map_indexed_inline:Nn #2
	{
		\tl_set:Nx \l__ndu_tmpa_tl { \seq_item:Nn #4 {##1} }
		\tl_if_blank:VF \l__ndu_tmpa_tl {
			\int_add:Nn #1 { \l__ndu_tmpa_tl * \int_use:c { l_ndu_factor_##2_ \tl_use:N {#3} _int } }
		}
	}
}
\cs_generate_variant:Nn \ndu_seq_to_repr:NNNN {
	NccN
}



% placeholder tokens for \ndu_format_helper
\tl_new:N \VALUE
\tl_new:N \SYMBOL

\tl_const:Nn \c__ndu_values_only_tl { values~only }
\tl_const:Nn \c__ndu_symbols_only_tl { symbols~only }
\tl_const:Nn \c__ndu_formatted_tl { formatted }

\cs_new_protected:Nn \ndu_format_helper:Nnnn
{
	% parameters
	% #1: output result (tl)
	% #2: format (tl)
	% #3: symbol (tl)
	% #4: value (int)
	\tl_case:Nn \l_ndu_display_choice_tl {
		\c__ndu_symbols_only_tl {
			\tl_set:Nn #1 { #3 }
		}
		\c__ndu_values_only_tl {
			\tl_set:Nn #1 { #4 }
		}
		\c__ndu_formatted_tl {
			\tl_set:Nn #1 { #2 }
			\tl_replace_all:Nnn #1 { \SYMBOL } { #3 }
			\tl_replace_all:Nnn #1 { \VALUE } { #4 }
		}
	}
}
\cs_generate_variant:Nn \ndu_format_helper:Nnnn {
	NVVn
}

\cs_new_protected:Nn \ndu_format_seq:nnn
{
	% parameters
	% #1: unit sequence (seq)
	% #2: amount sequence (seq)
	% #3: output result (seq)
	% scratch vars:
	% \l__ndu_tmpa_int: loop index
	% \l_tmpa_tl: current value
	% \l__ndu_tmpa_tl: formatted segment
	% \l_tmpa_seq: all formatted segments
	\seq_clear:N #3

	\seq_map_indexed_inline:Nn #2
	{
		\tl_clear_new:N \l_ndu_tmp_symbol_tl
		\tl_set:Nx \l_ndu_tmp_symbol_tl { \tl_use:c { l_ndu_symbol_ \seq_item:Nn {#1} {##1} _tl } }

		\tl_clear_new:N \l_ndu_tmp_format_tl
		\tl_if_empty:cTF { l_ndu_format_ \seq_item:Nn {#1} {##1} _tl }
		{
			\tl_set_eq:NN \l_ndu_tmp_format_tl \l_ndu_default_format_tl
		}
		{
			\tl_set_eq:Nc \l_ndu_tmp_format_tl { l_ndu_format_ \seq_item:Nn {#1} {##1} _tl }
		}

		\tl_if_blank:nTF {##2}
		{
			\tl_if_empty:NF {\l_ndu_replace_nil_with_tl}
			{
				\ndu_format_helper:NVVn
					\l__ndu_tmpa_tl
					\l_ndu_tmp_format_tl
					\l_ndu_tmp_symbol_tl
					{ \l_ndu_replace_nil_with_tl }
				\seq_put_right:Nx #3 { \l__ndu_tmpa_tl }
			}
		}
		{
			\bool_set:Nn \l_tmpa_bool { 
				\l_ndu_treat_zero_as_nil_bool &&
				\int_compare_p:n { ##2 = 0 }
			}
			\bool_if:NTF \l_tmpa_bool {
				\tl_if_empty:NF {\l_ndu_replace_nil_with_tl}
				{
					\ndu_format_helper:NVVn
						\l__ndu_tmpa_tl
						\l_ndu_tmp_format_tl
						\l_ndu_tmp_symbol_tl
						{ \l_ndu_replace_nil_with_tl }
					\seq_put_right:Nx #3 { \l__ndu_tmpa_tl }
				}
			}
			{
				\ndu_format_helper:NVVn
					\l__ndu_tmpa_tl
					\l_ndu_tmp_format_tl
					\l_ndu_tmp_symbol_tl
					{ ##2 }
				\seq_put_right:Nx #3 { \l__ndu_tmpa_tl }
			}
		}
	}
}

\cs_new_protected:Nn \ndu_format_value:NNNN
{
	% parameters
	% #1: output result (tl)
	% #2: unit sequence (seq)
	% #3: amount sequence (seq)
	% #4: separator (tl)
	\seq_clear:N \l_tmpa_seq

	\ndu_format_seq:nnn {#2} {#3} \l_tmpa_seq
	\tl_set:Nn #1 { \seq_use:Nn {\l_tmpa_seq} {#4} }
}
\cs_generate_variant:Nn \ndu_format_value:NNNN {
	NcNN
}

\cs_new_protected:Nn \ndu_format_value_aligned:NNNN
{
	% parameters
	% #1: output result (tl)
	% #2: unit sequence (seq)
	% #3: amount sequence (seq)
	% #4: cell width (dim)
	\tl_clear:N #1
	\seq_clear:N \l_tmpa_seq
	\ndu_format_seq:nnn {#2} {#3} \l_tmpa_seq

	\seq_map_indexed_inline:Nn \l_tmpa_seq
	{
		\box_clear_new:c { l__ndu_cell_ \int_to_alph:n {##1} _box }
		\hbox_set_to_wd:cnn { l__ndu_cell_ \int_to_alph:n {##1} _box } {#4} { \hfill ##2 }
		\tl_put_right:Nx #1 { \box_use:c { l__ndu_cell_ \int_to_alph:n {##1} _box } }
	}
}
\cs_generate_variant:Nn \ndu_format_value_aligned:NNNN {
	NcNN
}

\NewDocumentCommand \nduValue { m o m } {
	\group_begin:
		\IfValueT {#2} { \keys_set:nn { non-decimal-units } { #2 } }

		\tl_clear_new:N \l__ndu_result_tl
		\int_zero_new:N \l__ndu_normalized_int
		\seq_set_split:Nnn \l_tmpb_seq { . } {#3}

		% should we normalize the input?
		\bool_if:nT \l_ndu_normalize_bool
		{
			\ndu_seq_to_repr:NccN
				\l__ndu_normalized_int
				{ l_ndu_group_#1_seq }
				{ l_ndu_base_unit_#1_tl }
				\l_tmpb_seq
			\ndu_repr_to_seq:NccNc
				\l_tmpb_seq
				{ l_ndu_group_#1_seq }
				{ l_ndu_base_unit_#1_tl }
				\l__ndu_normalized_int
				{ l_ndu_base_unit_#1_tl }
		}

		% are we outputting aligned cells?
		\bool_if:NTF \l_ndu_aligned_bool
		{
			\ndu_format_value_aligned:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpb_seq
				\l_ndu_cell_width_dim
		}
		{
			\ndu_format_value:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpb_seq
				\l_ndu_segment_separator_tl
		}

		% should we do any math?
		\tl_if_empty:NF \l_ndu_current_variable_tl
		{
			\nduMath{#1}[#2]{\l_ndu_current_variable_tl}{\l_ndu_current_operator_tl}{#3}
		}

		% output
		\tl_use:N \l__ndu_result_tl
	\group_end:
}

\tl_const:Nn \c__ndu_plus_tl { + }
\tl_const:Nn \c__ndu_minus_tl { - }

\NewDocumentCommand \nduMath { m o m m m } {
	\group_begin:
		\IfValueT {#2} { \keys_set:nn { non-decimal-units } { #2 } }

		\int_if_exist:cF { g_ndu_variable_#3_int } {
			\int_zero_new:c { g_ndu_variable_#3_int }
		}

		\int_zero_new:N \l__ndu_operand_int

		\bool_if:nTF
		{
			\tl_if_eq_p:NN #4 \c__ndu_plus_tl ||
			\tl_if_eq_p:NN #4 \c__ndu_minus_tl
		}
		{
			% plus or minus means we use the representation of the provided value
			\seq_set_split:Nnn \l_tmpb_seq { . } { #5 }
			\ndu_seq_to_repr:NccN
				\l__ndu_operand_int
				{ l_ndu_group_#1_seq }
				{ l_ndu_base_unit_#1_tl }
				\l_tmpb_seq
		}
		{
			% otherwise (multiplication/division) we use the number provided directly
			\int_set:Nn \l__ndu_operand_int { #5 }
		}

		\int_gset:cn { g_ndu_variable_#3_int } {
			\int_use:c { g_ndu_variable_#3_int }
			#4
			\int_use:N \l__ndu_operand_int
		}
	\group_end:
}

\NewDocumentCommand \nduResult { m o m } {
	\group_begin:
		\IfValueT {#2} { \keys_set:nn { non-decimal-units } { #2 } }

		\int_if_exist:cF { g_ndu_variable_#3_int } {
			\int_zero_new:c { g_ndu_variable_#3_int }
		}

		\tl_clear_new:N \l__ndu_result_tl

		\ndu_repr_to_seq:Ncccc
			\l_tmpb_seq
			{ l_ndu_group_#1_seq }
			{ l_ndu_base_unit_#1_tl }
			{ g_ndu_variable_#3_int }
			{ l_ndu_base_unit_#1_tl }

		\bool_if:NTF \l_ndu_aligned_bool
		{
			\ndu_format_value_aligned:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpb_seq
				\l_ndu_cell_width_dim
		}
		{
			\ndu_format_value:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpb_seq
				\l_ndu_segment_separator_tl
		}
		\tl_use:N \l__ndu_result_tl
	\group_end:
}

\ExplSyntaxOff

\begin{document}

4.3.2.1: \hfill \nduValue{danish rigsdaler}[]{4.3.2.1}

.1.: \hfill \nduValue{danish rigsdaler}{.1.}

1..1 with comma sep: \hfill \nduValue{danish rigsdaler}[segment separator={,}]{1..1}

1.2.3: \hfill \nduValue{danish rigsdaler}{1.2.3}

1.0.1 treat zero as nil: \hfill \nduValue{danish rigsdaler}[treat zero as nil]{1.0.1}

1.2.3 with format: \hfill \nduValue{danish rigsdaler}[units/rigsdaler/format={ (\SYMBOL\ \VALUE) }]{1.2.3}

1.2.3 values only: \hfill \nduValue{danish rigsdaler}[display=values only]{1.2.3}

1.2.3 symbols only: \hfill \nduValue{danish rigsdaler}[display=symbols only]{1.2.3}

1.2.3 formatted: \hfill \nduValue{danish rigsdaler}[display=formatted]{1.2.3}

normalize:

..100: \hfill \nduValue{danish rigsdaler}{..100}

..100 normalized: \hfill \nduValue{danish rigsdaler}[normalize]{..100}

..100 normalized, treat zero as nil: \hfill \nduValue{danish rigsdaler}[normalize, treat zero as nil]{..100}

aligned:

1.2.3: \hfill \nduValue{danish rigsdaler}[aligned, cell width=5em]{1.2.3}

1..3: \hfill \nduValue{danish rigsdaler}[aligned, cell width=5em, replace nil with={---}]{1..3}

math:

1.2.3: \hfill \nduValue{danish rigsdaler}[add to variable=test 1]{1.2.3}

1.2.3: \hfill \nduValue{danish rigsdaler}[add to variable=test 1]{1.2.3}

1.2.3: \hfill \nduValue{danish rigsdaler}[add to variable=test 1]{1.2.3}

result: \hfill \nduResult{danish rigsdaler}{test 1}

* 3: \hfill \nduMath{danish rigsdaler}{test 1}{*}{3}

result: \hfill \nduResult{danish rigsdaler}{test 1}

/ 2: \hfill \nduMath{danish rigsdaler}{test 1}{/}{2}

result: \hfill \nduResult{danish rigsdaler}{test 1}

macro: \hfill \rdl{1.2.3}

macro with comma sep: \hfill \rdl[segment separator={,}]{1.2.3}

\end{document}

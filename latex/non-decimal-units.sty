\RequirePackage{expl3}
\ProvidesExplPackage{non-decimal-units}{2023/09/27}{1.0}{Macros for displaying and manipulating historical non-decimal units}

% License: CC-BY-SA 4.0
% Author: Mikkel Eide Eriksen <mikkel.eriksen@gmail.com>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Key setup
% 

\keys_define:nn { non-decimal-units }
{
	% nil/zero
	replace~nil~with 			.tl_set:N		= \l_ndu_replace_nil_with_tl ,
	treat~zero~as~nil 			.bool_set:N 	= \l_ndu_treat_zero_as_nil_bool ,
	treat~zero~as~nil 			.default:n 		= true ,

	% formatting
	unit~separator 				.tl_set:N		= \l_ndu_unit_separator_tl ,
	unit~separator				.default:n		= { \nobreakspace } ,
	default~format				.tl_set:N		= \l_ndu_default_format_tl ,
	default~format				.default:n		= { \VALUE\nobreakspace\SYMBOL } ,
	display						.choice: ,
	display						.choices:nn		= 
		{ values~only, symbols~only, formatted }
		{ \tl_set_eq:NN \l_ndu_display_choice_tl \l_keys_choice_tl } ,
	display						.default:n		= { formatted } ,
	unit~depth					.tl_set:N		= \l_ndu_unit_depth_tl ,

	% tabular alignment
	aligned						.bool_set:N		= \l_ndu_aligned_bool ,
	aligned						.default:n 		= true ,
	cell~width					.dim_set:N		= \l_ndu_cell_width_dim ,
	cell~width 					.default:n 		= 3em ,

	% math
	normalize 					.bool_set:N		= \l_ndu_normalize_bool ,
	normalize 					.default:n 		= true ,
	current~variable			.tl_set:N		= \l_ndu_current_variable_tl ,
	current~operator			.tl_set:N		= \l_ndu_current_operator_tl ,
	add~to~variable				.meta:n			= {
			current~variable = {#1} ,
			current~operator = {+}
		} ,
	subtract~from~variable		.meta:n			= {
			current~variable = {#1} ,
			current~operator = {-}
		} ,
	
	% environments
	set~aligned~for~environment	.code			= {
			\AtBeginEnvironment{#1}{\nduKeys{aligned}}
		} ,
}

\NewDocumentCommand { \nduKeys } { m } {
	\keys_set:nn { non-decimal-units } { #1 }
}

% set some defaults
\keys_set:nn { non-decimal-units } {
	unit~separator,
	default~format,
	display,
	cell~width,
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Unit setup
% 

\NewDocumentCommand { \nduNewBaseUnit } { m m } {
	\prop_clear_new:c { l_ndu_factors_#1_prop }
	\keys_define:nn { non-decimal-units / units / #1 } {
		factor				.code			= {
			\regex_extract_once:nnN { (\d+)\ (\w+) } { ##1 } \l_tmpa_seq
			\prop_put:cxx { l_ndu_factors_#1_prop } { \seq_item:Nn \l_tmpa_seq 3 } { \seq_item:Nn \l_tmpa_seq 2 }
		} ,
		symbol				.tl_set:c		= { l_ndu_symbol_#1_tl } ,
		format				.tl_set:c		= { l_ndu_format_#1_tl } ,
	}
	\keys_set:nn { non-decimal-units / units / #1 } { #2 }
}

\NewDocumentCommand { \nduNewUnitGroup } { m o m o }
{
	\seq_set_from_clist:cn { l_ndu_group_#1_seq } {#3}

	% set base unit to rightmost item
	\seq_get_right:cN { l_ndu_group_#1_seq } \l_tmpa_tl
	\tl_set_eq:cN { l_ndu_base_unit_#1_tl } \l_tmpa_tl

	% store keys for unit group
	\tl_clear_new:c { l_ndu_options_#1_tl }
	\IfValueT {#2} {
		\tl_set:cn { l_ndu_options_#1_tl } {#2}
	}

	% optionally create macro
	\IfValueT {#4} {
		\NewDocumentCommand { #4 } { O{} m } {
			\group_begin:
				\IfValueT {#2} {
					\nduValue{#1}[#2,##1]{##2}
				}
				{
					\nduValue{#1}[##1]{##2}
				}
			\group_end:
		}
	}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conversion factor initialization and access
% 

\msg_new:nnnn
{ non-decimal-units } { missing-factor }
{ No ~ conversion ~ factor ~ exists ~ between ~ #1 ~ and ~ #2 }
{ You ~ will ~ need ~ to ~ add ~ it ~ when ~ creating ~ the ~ base ~ unit ~ or ~ via ~ nduKeys. }

\cs_new_protected:Nn \ndu_get_factor:Nnn
{
	% parameters
	% #1: output result (int)
	% #2: from unit (tl)
	% #3: to unit (tl)
	\str_if_eq:nnTF {#2} {#3}
	{
		\int_set:Nn #1 { 1 }
	}
	{
		\prop_if_in:cnTF { l_ndu_factors_#2_prop } { #3 }
		{
			\prop_get:cnN  { l_ndu_factors_#2_prop } { #3 } \l_tmpa_tl
			\int_set:Nn #1 { \l_tmpa_tl }
		}{
			\int_zero_new:N \l__ndu_factor_product_int
			\prop_map_inline:cn { l_ndu_factors_#2_prop } {
				\str_if_eq:nnF {#3} {##1}
				{
					\int_zero_new:N \l__ndu_sub_factor_int
					\ndu_get_factor:Nnn \l__ndu_sub_factor_int { ##1 } { #3 }
					\int_set:Nn \l__ndu_factor_product_int { ##2 * \l__ndu_sub_factor_int }
					\int_set:Nn #1 { \l__ndu_factor_product_int }
					\prop_put:cnx { l_ndu_factors_#2_prop } { #3 } { \int_use:N \l__ndu_factor_product_int }
				}
			}
		}
	}
}
\cs_generate_variant:Nn \ndu_get_factor:Nnn {
	NnV,
	NVV
}

% ndu_super_factors (call from nduNewUnitGroup)

\NewDocumentCommand \nduFactor { m m } {
	\ndu_get_factor:Nnn \l_tmpa_int { #1 } { #2 }
	\int_use:N \l_tmpa_int
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Converting from/to representation
% 

\cs_new_protected:Nn \ndu_repr_to_seq:NNNNN
{
	% parameters
	% #1: output result (seq)
	% #2: unit group (seq)
	% #3: base unit (tl)
	% #4: value (int)
	% #5: unit (tl)
	\seq_clear:N #1

	\int_zero_new:N \l__ndu_remainder_int

	% initial value * base factor
	\ndu_get_factor:NVV \l_tmpa_int { #5 } { #3 }
	\int_set:Nn \l__ndu_remainder_int { #4 * \l_tmpa_int }

	% for unit in units:
	\seq_map_inline:Nn #2
	{
		\int_zero_new:N \l__ndu_factor_int
		\int_zero_new:N \l__ndu_sum_int

		\ndu_get_factor:NnV \l__ndu_factor_int { ##1 } { #3 }

		% while (remainder >= factor_to_base):
		\int_while_do:nn {\l__ndu_remainder_int >= \l__ndu_factor_int} {
			% remainder -= factor_to_base
			\int_sub:Nn \l__ndu_remainder_int \l__ndu_factor_int
			% result[i] += 1
			\int_incr:N \l__ndu_sum_int
		}
		\seq_put_right:Nx #1 {\int_use:N \l__ndu_sum_int}
		
		% stop when we hit the desired unit depth
		\str_if_eq:NNT {##1} {#5} {
			\seq_map_break:
		}
	}
}
\cs_generate_variant:Nn \ndu_repr_to_seq:NNNNN {
	NccNc,
	Ncccc
}

\cs_new_protected:Nn \ndu_repr_to_seq:NnN
{
	% parameters
	% #1: output result (int)
	% #2: unit group name (tl)
	% #3: value (int)
	\ndu_repr_to_seq:NccNc
		#1
		{ l_ndu_group_#2_seq }
		{ l_ndu_base_unit_#2_tl }
		#3
		{ l_ndu_base_unit_#2_tl }

}
\cs_generate_variant:Nn \ndu_repr_to_seq:NnN {
	Nnc
}


\cs_new_protected:Nn \ndu_seq_to_repr:NNNN
{
	% parameters
	% #1: output result (int)
	% #2: unit group (seq)
	% #3: base unit (tl)
	% #4: input (seq)
	\int_zero:N #1

	\seq_map_indexed_inline:Nn #2
	{
		\tl_set:Nx \l__ndu_value_tl { \seq_item:Nn #4 {##1} }
		\tl_if_blank:VF \l__ndu_value_tl {
			\ndu_get_factor:NnV \l_tmpa_int { ##2 } { #3 }
			\int_add:Nn #1 { \l__ndu_value_tl * \l_tmpa_int }
		}
	}
}
\cs_generate_variant:Nn \ndu_seq_to_repr:NNNN {
	NccN
}

\cs_new_protected:Nn \ndu_seq_to_repr:NnN
{
	% parameters
	% #1: output result (seq)
	% #2: unit group name (tl)
	% #3: values (seq)
	\ndu_seq_to_repr:NccN
		#1
		{ l_ndu_group_#2_seq }
		{ l_ndu_base_unit_#2_tl }
		#3
}
\cs_generate_variant:Nn \ndu_seq_to_repr:NnN {
	Nnc
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Formatting values
% 

\prg_new_protected_conditional:Nnn \ndu_if_not_nil_or_zero:Nn {T,TF}
{
	% parameters
	% #1: output result (tl)
	% #2: value (tl)
	% returns T if value should be output, otherwise F

	\tl_if_blank:nTF {#2}
	{
		% only output something if we are replacing nil
		\tl_if_empty:NTF {\l_ndu_replace_nil_with_tl}
		{
			\prg_return_false:
		}
		{
			\tl_set_eq:NN #1 \l_ndu_replace_nil_with_tl
			\prg_return_true:
		}
	}
	{
		\bool_if:nTF {
			\l_ndu_treat_zero_as_nil_bool &&
			\int_compare_p:n { #2 = 0 }
		} {
			% only output something if we are replacing nil
			\tl_if_empty:NTF {\l_ndu_replace_nil_with_tl}
			{
				\prg_return_false:
			}
			{
				\tl_set_eq:NN #1 \l_ndu_replace_nil_with_tl
				\prg_return_true:
			}
		}
		{
			% else output form
			\tl_set:Nx #1 {#2}
			\prg_return_true:
		}
	}
}
\prg_generate_conditional_variant:Nnn \ndu_if_not_nil_or_zero:Nn
{
	Nx
}
{
	T,TF
}

% placeholder tokens for \ndu_format_display_helper
\tl_new:N \VALUE
\tl_new:N \SYMBOL

\tl_const:Nn \c__ndu_values_only_tl { values~only }
\tl_const:Nn \c__ndu_symbols_only_tl { symbols~only }
\tl_const:Nn \c__ndu_formatted_tl { formatted }

\cs_new_protected:Nn \ndu_format_display_helper:Nnnn
{
	% parameters
	% #1: output result (tl)
	% #2: format (tl)
	% #3: symbol (tl)
	% #4: value (int)
	\tl_case:Nn \l_ndu_display_choice_tl {
		\c__ndu_symbols_only_tl {
			\tl_set:Nn #1 { #3 }
		}
		\c__ndu_values_only_tl {
			\tl_set:Nn #1 { #4 }
		}
		\c__ndu_formatted_tl {
			\tl_set:Nn #1 { #2 }
			\tl_replace_all:Nnn #1 { \SYMBOL } { #3 }
			\tl_replace_all:Nnn #1 { \VALUE } { #4 }
		}
	}
}
\cs_generate_variant:Nn \ndu_format_display_helper:Nnnn {
	NVVn,
	NVVx
}

\cs_new_protected:Nn \ndu_format_seq:NNN
{
	% parameters
	% #1: output result (seq)
	% #2: unit group (seq)
	% #3: values (seq)
	\seq_clear:N #1

	\seq_map_indexed_inline:Nn #3
	{
		\tl_clear_new:N \l__ndu_formatted_segment
		\tl_clear_new:N \l__ndu_symbol_tl
		\tl_set:Nx \l__ndu_unit_tl { \seq_item:Nn #2 {##1} }
		\tl_set:Nx \l__ndu_symbol_tl { \tl_use:c { l_ndu_symbol_ \seq_item:Nn #2 {##1} _tl } }

		\tl_clear_new:N \l__ndu_format_tl
		\tl_if_empty:cTF { l_ndu_format_ \seq_item:Nn #2 {##1} _tl }
		{
			\tl_set_eq:NN \l__ndu_format_tl \l_ndu_default_format_tl
		}
		{
			\tl_set_eq:Nc \l__ndu_format_tl { l_ndu_format_ \seq_item:Nn #2 {##1} _tl }
		}

		\ndu_if_not_nil_or_zero:NnT \l_tmpa_tl { ##2 }
		{
			\ndu_format_display_helper:NVVx
				\l__ndu_formatted_segment
				\l__ndu_format_tl
				\l__ndu_symbol_tl
				{ \l_tmpa_tl }
			\seq_put_right:Nx #1 \l__ndu_formatted_segment
		}

		% stop when we hit the desired unit depth
		\tl_if_eq:NNT \l__ndu_unit_tl \l_ndu_unit_depth_tl
		{
			\seq_map_break:
		}
	}
}

\cs_new_protected:Nn \ndu_format_values:NNNN
{
	% parameters
	% #1: output result (tl)
	% #2: unit group (seq)
	% #3: values (seq)
	% #4: separator (tl)
	\seq_clear_new:N \l__ndu_formatted_segments_seq
	\ndu_format_seq:NNN \l__ndu_formatted_segments_seq #2 #3
	\tl_set:Nn #1 { \seq_use:Nn {\l__ndu_formatted_segments_seq} {#4} }
}
\cs_generate_variant:Nn \ndu_format_values:NNNN {
	NcNN
}

\cs_new_protected:Nn \ndu_format_value_aligned:NNNN
{
	% parameters
	% #1: output result (tl)
	% #2: unit group (seq)
	% #3: values (seq)
	% #4: cell width (dim)
	\tl_clear:N #1

	\seq_map_indexed_inline:Nn #2
	{
		\tl_clear_new:N \l__ndu_value_tl
		\box_clear_new:c { l__ndu_cell_ \int_to_alph:n {##1} _box }
		\ndu_if_not_nil_or_zero:NxTF \l__ndu_value_tl { \seq_item:Nn #3 ##1 }
		{
			\hbox_set_to_wd:cnn { l__ndu_cell_ \int_to_alph:n {##1} _box } {#4} {
				\hfill \tl_use:N \l__ndu_value_tl
			}
		}
		{
			\hbox_set_to_wd:cnn { l__ndu_cell_ \int_to_alph:n {##1} _box } {#4} {
				\hfill
			}
		}

		\tl_put_right:Nx #1 { \box_use:c { l__ndu_cell_ \int_to_alph:n {##1} _box } }

		% stop when we hit the desired unit depth
		\tl_if_eq:NnT \l_ndu_unit_depth_tl {##2}
		{
			\seq_map_break:
		}
	}
}
\cs_generate_variant:Nn \ndu_format_value_aligned:NNNN {
	NcNN
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% User commands
% 


\cs_new_protected:Nn \ndu_set_options:nn
{
	% set keys for unit group
	\tl_if_eq:cnF { l_ndu_options_#1_tl } { \c_novalue_tl }
	{
		\keys_set:nv { non-decimal-units } { l_ndu_options_#1_tl } 
	}

	% set keys provided by command
	\IfValueT {#2} { \keys_set:nn { non-decimal-units } { #2 } }
}

\NewDocumentCommand \nduValue { m o m } {
	\group_begin:
		\ndu_set_options:nn {#1} {#2}

		\tl_clear_new:N \l__ndu_result_tl
		\int_zero_new:N \l__ndu_normalized_int
		\seq_set_split:Nnn \l_tmpa_seq { . } {#3}

		% should we normalize the input?
		\bool_if:nT \l_ndu_normalize_bool
		{
			\ndu_seq_to_repr:NnN
				\l__ndu_normalized_int
				{ #1 }
				\l_tmpa_seq
			\ndu_repr_to_seq:NnN
				\l_tmpa_seq
				{ #1 }
				\l__ndu_normalized_int
		}

		% are we outputting aligned cells?
		\bool_if:NTF \l_ndu_aligned_bool
		{
			\ndu_format_value_aligned:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpa_seq
				\l_ndu_cell_width_dim
		}
		{
			\ndu_format_values:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpa_seq
				\l_ndu_unit_separator_tl
		}

		% should we do any math?
		\tl_if_empty:NF \l_ndu_current_variable_tl
		{
			\nduMath{#1}[#2]{\l_ndu_current_variable_tl}{\l_ndu_current_operator_tl}{#3}
		}

		% output
		\tl_use:N \l__ndu_result_tl
	\group_end:
}

\tl_const:Nn \c__ndu_plus_tl { + }
\tl_const:Nn \c__ndu_minus_tl { - }

\NewDocumentCommand \nduMath { m o m m m } {
	\group_begin:
		\ndu_set_options:nn {#1} {#2}

		\int_if_exist:cF { g_ndu_variable_#3_int } {
			\int_zero_new:c { g_ndu_variable_#3_int }
		}

		\int_zero_new:N \l__ndu_operand_int

		\bool_if:nTF
		{
			% TODO hacky, but works
			\str_if_eq_p:nV {#4} \c__ndu_plus_tl ||
			\str_if_eq_p:nV {#4} \c__ndu_minus_tl ||
			\tl_if_eq_p:NN {#4} \c__ndu_plus_tl ||
			\tl_if_eq_p:NN {#4} \c__ndu_minus_tl
		}
		{
			% plus or minus means we use the representation of the provided value
			\seq_set_split:Nnn \l_tmpa_seq { . } { #5 }
			\ndu_seq_to_repr:NnN
				\l__ndu_operand_int
				{ #1 }
				\l_tmpa_seq
		}
		{
			% otherwise (multiplication/division) we use the number provided directly
			\int_set:Nn \l__ndu_operand_int { #5 }
		}

		\int_gset:cn { g_ndu_variable_#3_int } {
			\int_use:c { g_ndu_variable_#3_int }
			#4
			\l__ndu_operand_int
		}
	\group_end:
}

\NewDocumentCommand \nduResult { m o m } {
	\group_begin:
		\ndu_set_options:nn {#1} {#2}

		\int_if_exist:cF { g_ndu_variable_#3_int } {
			\int_zero_new:c { g_ndu_variable_#3_int }
		}

		\tl_clear_new:N \l__ndu_result_tl

		\ndu_repr_to_seq:Nnc
			\l_tmpa_seq
			{ #1 }
			{ g_ndu_variable_#3_int }

		% are we outputting aligned cells?
		\bool_if:NTF \l_ndu_aligned_bool
		{
			\ndu_format_value_aligned:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpa_seq
				\l_ndu_cell_width_dim
%\seq_show:N \l_tmpa_seq
%\tl_show:N \l__ndu_result_tl
		}
		{
			\ndu_format_values:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpa_seq
				\l_ndu_unit_separator_tl
		}

		% output
		\tl_use:N \l__ndu_result_tl
	\group_end:
}

\NewDocumentCommand \nduHeader { m o } {
	\group_begin:
		\ndu_set_options:nn {#1} {#2}

		% build boxes
		\seq_set_eq:Nc \l_tmpa_seq { l_ndu_group_#1_seq }
		\seq_map_indexed_inline:Nn \l_tmpa_seq
		{
			\box_clear_new:c { l__ndu_cell_ \int_to_alph:n {##1} _box }
			\hbox_set_to_wd:cnn
				{ l__ndu_cell_ \int_to_alph:n {##1} _box }
				{ \l_ndu_cell_width_dim }
				{ \hfill \tl_use:c { l_ndu_symbol_ ##2 _tl } }
			\tl_put_right:Nn \l__ndu_result_tl { \box_use:c { l__ndu_cell_ \int_to_alph:n {##1} _box } }

			% stop when we hit the desired unit depth
			\tl_set:Nn \l_tmpa_tl {##2}
			\tl_if_eq:NNT \l_tmpa_tl \l_ndu_unit_depth_tl
			{
				\seq_map_break:
			}
		}

		% output
		\tl_use:N \l__ndu_result_tl
	\group_end:
}

\NewDocumentCommand \nduSymbol { m } {
	\tl_use:c { l_ndu_symbol_#1_tl }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Setup
% 

\keys_define:nn { non-decimal-units / options }
{
	british	 					.code:n 		= { \input{non-decimal-units.british} } ,
	danish	 					.code:n 		= { \input{non-decimal-units.danish} } ,
	german	 					.code:n 		= { \input{non-decimal-units.german} } ,
}

\IfFormatAtLeastTF { 2022-06-01 } {
    \ProcessKeyOptions [ non-decimal-units / options ]
}{
    \RequirePackage { l3keys2e }
    \ProcessKeysOptions { non-decimal-units / options }
}
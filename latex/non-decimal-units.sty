\RequirePackage{expl3}
\ProvidesExplPackage{non-decimal-units}{2023/09/27}{1.0}{Macros for displaying and manipulating historical non-decimal units}

% License: CC-BY-SA 4.0
% Author: Mikkel Eide Eriksen <mikkel.eriksen@gmail.com>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Key setup
% 

\keys_define:nn { non-decimal-units }
{
	% nil/zero
	replace~nil~with 			.tl_set:N		= \l_ndu_replace_nil_with_tl ,
	treat~zero~as~nil 			.bool_set:N 	= \l_ndu_treat_zero_as_nil_bool ,
	treat~zero~as~nil 			.default:n 		= true ,

	% formatting
	segment~separator 			.tl_set:N		= \l_ndu_segment_separator_tl ,
	segment~separator			.default:n		= { ~ } ,
	default~format				.tl_set:N		= \l_ndu_default_format_tl ,
	default~format				.default:n		= { \VALUE\ \SYMBOL } ,
	display						.choice: ,
	display						.choices:nn		= 
		{ values~only, symbols~only, formatted }
		{ \tl_set_eq:NN \l_ndu_display_choice_tl \l_keys_choice_tl } ,
	display						.default:n		= { formatted } ,
	unit~depth					.tl_set:N		= \l_ndu_unit_depth_tl ,

	% tabular alignment
	aligned						.bool_set:N		= \l_ndu_aligned_bool ,
	aligned						.default:n 		= true ,
	cell~width					.dim_set:N		= \l_ndu_cell_width_dim ,
	cell~width 					.default:n 		= 3em ,

	% math
	normalize 					.bool_set:N		= \l_ndu_normalize_bool ,
	normalize 					.default:n 		= true ,
	current~variable			.tl_set:N		= \l_ndu_current_variable_tl ,
	current~operator			.tl_set:N		= \l_ndu_current_operator_tl ,
	add~to~variable				.meta:n			= {
			current~variable = {#1} ,
			current~operator = {+}
		} ,
	subtract~from~variable		.meta:n			= {
			current~variable = {#1} ,
			current~operator = {-}
		} ,
	
	% environments
	set~aligned~for~environment	.code			= {
			\AtBeginEnvironment{#1}{\nduKeys{aligned}}
		} ,
}

\NewDocumentCommand { \nduKeys } { m } {
	\keys_set:nn { non-decimal-units } { #1 }
}

% set some defaults
\keys_set:nn { non-decimal-units } {
	segment~separator,
	default~format,
	display,
	cell~width,
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Unit setup
% 

\NewDocumentCommand { \nduNewBaseUnit } { m m } {
%	\int_set:cn { l_ndu_factor_#1_#1_int } { 1 }
	\keys_define:nn { non-decimal-units / units / #1 } {
		factor				.code			= {
			\regex_extract_once:nnN { (\d+)\ (\w+) } { ##1 } \l_tmpa_seq
			\int_zero_new:c { l_ndu_factor_#1_ \seq_item:Nn \l_tmpa_seq 3 _int }
			\int_set:cn { l_ndu_factor_#1_ \seq_item:Nn \l_tmpa_seq 3 _int } { \seq_item:Nn \l_tmpa_seq 2 }
		} ,
		symbol				.tl_set:c		= { l_ndu_symbol_#1_tl } ,
		format				.tl_set:c		= { l_ndu_format_#1_tl } ,
	}
	\int_zero_new:c { l_ndu_factor_#1_#1_int }
	\int_set:cn { l_ndu_factor_#1_#1_int } { 1 }
	\keys_set:nn { non-decimal-units / units / #1 } { #2 }
}

\NewDocumentCommand { \nduNewUnitGroup } { m o m o }
{
	\seq_set_from_clist:cn { l_ndu_group_#1_seq } {#3}

	% set base unit to rightmost item
	\seq_get_right:cN { l_ndu_group_#1_seq } \l_tmpa_tl
	\tl_set_eq:cN { l_ndu_base_unit_#1_tl } \l_tmpa_tl

	% store keys for unit group
	\tl_clear_new:c { l_ndu_options_#1_tl }
	\IfValueT {#2} {
		\tl_set:cn { l_ndu_options_#1_tl } {#2}
	}

	% optionally create macro
	\IfValueT {#4} {
		\NewDocumentCommand { #4 } { O{} m } {
			\group_begin:
				\IfValueT {#2} {
					\nduValue{#1}[#2,##1]{##2}
				}
				{
					\nduValue{#1}[##1]{##2}
				}
			\group_end:
		}
	}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Converting from/to representation
% 

\cs_new_protected:Nn \ndu_repr_to_seq:NNNNN
{
	% parameters
	% #1: output result (seq)
	% #2: unit group (seq)
	% #3: base unit (tl)
	% #4: value (int)
	% #5: unit (tl)
	\seq_clear:N #1

	\int_zero_new:N \l__ndu_remainder_int

	% initial value * base factor
	\int_set:Nn \l__ndu_remainder_int { #4 * \int_use:c { l_ndu_factor_#5_ \tl_use:N {#3} _int } }

	% for i, (name, factor) in enumerate(units):
	\seq_map_inline:Nn #2
	{
		\int_zero_new:N \l__ndu_factor_int
		\int_zero_new:N \l__ndu_sum_int

		\int_set:Nn \l__ndu_factor_int { \int_use:c { l_ndu_factor_##1_ \tl_use:N {#3} _int } }

		% while (remainder >= factor):
		\int_while_do:nn {\l__ndu_remainder_int >= \l__ndu_factor_int} {
			% remainder -= factor
			\int_sub:Nn \l__ndu_remainder_int \l__ndu_factor_int
			% result[i] += 1
			\int_incr:N \l__ndu_sum_int
		}
		\seq_put_right:Nx #1 {\int_use:N \l__ndu_sum_int}
		
		% stop when we hit the desired unit depth
		\str_if_eq:NNT {##1} {#5} {
			\seq_map_break:
		}
	}
}
\cs_generate_variant:Nn \ndu_repr_to_seq:NNNNN {
	NccNc,
	Ncccc
}



\cs_new_protected:Nn \ndu_seq_to_repr:NNNN
{
	% parameters
	% #1: output result (int)
	% #2: unit group (seq)
	% #3: base unit (tl)
	% #4: input (seq)
	\int_zero:N #1

	\seq_map_indexed_inline:Nn #2
	{
		\tl_set:Nx \l__ndu_value_tl { \seq_item:Nn #4 {##1} }
		\tl_if_blank:VF \l__ndu_value_tl {
			\int_add:Nn #1 { \l__ndu_value_tl * \int_use:c { l_ndu_factor_##2_ \tl_use:N {#3} _int } }
		}
	}
}
\cs_generate_variant:Nn \ndu_seq_to_repr:NNNN {
	NccN
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Formatting values
% 

% placeholder tokens for \ndu_format_helper
\tl_new:N \VALUE
\tl_new:N \SYMBOL

\tl_const:Nn \c__ndu_values_only_tl { values~only }
\tl_const:Nn \c__ndu_symbols_only_tl { symbols~only }
\tl_const:Nn \c__ndu_formatted_tl { formatted }

\cs_new_protected:Nn \ndu_format_helper:Nnnn
{
	% parameters
	% #1: output result (tl)
	% #2: format (tl)
	% #3: symbol (tl)
	% #4: value (int)
	\tl_case:Nn \l_ndu_display_choice_tl {
		\c__ndu_symbols_only_tl {
			\tl_set:Nn #1 { #3 }
		}
		\c__ndu_values_only_tl {
			\tl_set:Nn #1 { #4 }
		}
		\c__ndu_formatted_tl {
			\tl_set:Nn #1 { #2 }
			\tl_replace_all:Nnn #1 { \SYMBOL } { #3 }
			\tl_replace_all:Nnn #1 { \VALUE } { #4 }
		}
	}
}
\cs_generate_variant:Nn \ndu_format_helper:Nnnn {
	NVVn
}

\cs_new_protected:Nn \ndu_format_seq:NNN
{
	% parameters
	% #1: output result (seq)
	% #2: unit group (seq)
	% #3: values (seq)
	\seq_clear:N #1

	\seq_map_indexed_inline:Nn #3
	{
		\tl_clear_new:N \l__ndu_formatted_segment
		\tl_clear_new:N \l__ndu_symbol_tl
		\tl_set:Nx \l__ndu_unit_tl { \seq_item:Nn #2 {##1} }
		\tl_set:Nx \l__ndu_symbol_tl { \tl_use:c { l_ndu_symbol_ \seq_item:Nn #2 {##1} _tl } }

		\tl_clear_new:N \l__ndu_format_tl
		\tl_if_empty:cTF { l_ndu_format_ \seq_item:Nn #2 {##1} _tl }
		{
			\tl_set_eq:NN \l__ndu_format_tl \l_ndu_default_format_tl
		}
		{
			\tl_set_eq:Nc \l__ndu_format_tl { l_ndu_format_ \seq_item:Nn #2 {##1} _tl }
		}

		\tl_if_blank:nTF {##2}
		{
			% only output something if we are replacing nil
			\tl_if_empty:NF {\l_ndu_replace_nil_with_tl}
			{
				\ndu_format_helper:NVVn
					\l__ndu_formatted_segment
					\l__ndu_format_tl
					\l__ndu_symbol_tl
					{ \l_ndu_replace_nil_with_tl }
				\seq_put_right:NV #1 \l__ndu_formatted_segment
			}
		}
		{
			\bool_if:nTF {
				\l_ndu_treat_zero_as_nil_bool &&
				\int_compare_p:n { ##2 = 0 }
			} {
				\tl_if_empty:NF {\l_ndu_replace_nil_with_tl}
				{
					\ndu_format_helper:NVVn
						\l__ndu_formatted_segment
						\l__ndu_format_tl
						\l__ndu_symbol_tl
						{ \l_ndu_replace_nil_with_tl }
					\seq_put_right:NV #1 \l__ndu_formatted_segment
				}
			}
			{
				\ndu_format_helper:NVVn
					\l__ndu_formatted_segment
					\l__ndu_format_tl
					\l__ndu_symbol_tl
					{ ##2 }
				\seq_put_right:NV #1 \l__ndu_formatted_segment
			}
		}
		
		% stop when we hit the desired unit depth
		\tl_if_eq:NNT \l__ndu_unit_tl \l_ndu_unit_depth_tl
		{
			\seq_map_break:
		}
	}
}

\cs_new_protected:Nn \ndu_format_values:NNNN
{
	% parameters
	% #1: output result (tl)
	% #2: unit group (seq)
	% #3: values (seq)
	% #4: separator (tl)
	\seq_clear:N \l_tmpa_seq
	\ndu_format_seq:NNN \l_tmpa_seq #2 #3
	\tl_set:Nn #1 { \seq_use:Nn {\l_tmpa_seq} {#4} }
}
\cs_generate_variant:Nn \ndu_format_values:NNNN {
	NcNN
}

\cs_new_protected:Nn \ndu_format_value_aligned:NNNN
{
	% parameters
	% #1: output result (tl)
	% #2: unit group (seq)
	% #3: values (seq)
	% #4: cell width (dim)
	\tl_clear:N #1
	\seq_clear:N \l_tmpa_seq
	\ndu_format_seq:NNN \l_tmpa_seq #2 #3

	\seq_map_indexed_inline:Nn #2
	{
		\box_clear_new:c { l__ndu_cell_ \int_to_alph:n {##1} _box }
		\hbox_set_to_wd:cnn { l__ndu_cell_ \int_to_alph:n {##1} _box } {#4} { \hfill \seq_item:Nn #3 ##1 }
		\tl_put_right:Nx #1 { \box_use:c { l__ndu_cell_ \int_to_alph:n {##1} _box } }

		% stop when we hit the desired unit depth
		\tl_if_eq:NnT \l_ndu_unit_depth_tl {##2}
		{
			\seq_map_break:
		}
	}
}
\cs_generate_variant:Nn \ndu_format_value_aligned:NNNN {
	NcNN
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% User commands
% 

\NewDocumentCommand \nduValue { m o m } {
	\group_begin:
		% set keys for unit group
		\tl_if_eq:cnF { l_ndu_options_#1_tl } { \c_novalue_tl }
		{
			\keys_set:nv { non-decimal-units } { l_ndu_options_#1_tl } 
		}

		% set keys provided by command
		\IfValueT {#2} { \keys_set:nn { non-decimal-units } { #2 } }

		\tl_clear_new:N \l__ndu_result_tl
		\int_zero_new:N \l__ndu_normalized_int
		\seq_set_split:Nnn \l_tmpb_seq { . } {#3}

		% should we normalize the input?
		\bool_if:nT \l_ndu_normalize_bool
		{
			\ndu_seq_to_repr:NccN
				\l__ndu_normalized_int
				{ l_ndu_group_#1_seq }
				{ l_ndu_base_unit_#1_tl }
				\l_tmpb_seq
			\ndu_repr_to_seq:NccNc
				\l_tmpb_seq
				{ l_ndu_group_#1_seq }
				{ l_ndu_base_unit_#1_tl }
				\l__ndu_normalized_int
				{ l_ndu_base_unit_#1_tl }
		}

		% are we outputting aligned cells?
		\bool_if:NTF \l_ndu_aligned_bool
		{
			\ndu_format_value_aligned:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpb_seq
				\l_ndu_cell_width_dim
		}
		{
			\ndu_format_values:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpb_seq
				\l_ndu_segment_separator_tl
		}

		% should we do any math?
		\tl_if_empty:NF \l_ndu_current_variable_tl
		{
			\nduMath{#1}[#2]{\l_ndu_current_variable_tl}{\l_ndu_current_operator_tl}{#3}
		}

		% output
		\tl_use:N \l__ndu_result_tl
	\group_end:
}

\tl_const:Nn \c__ndu_plus_tl { + }
\tl_const:Nn \c__ndu_minus_tl { - }

\NewDocumentCommand \nduMath { m o m m m } {
	\group_begin:
		% set keys for unit group
		\tl_if_eq:cnF { l_ndu_options_#1_tl } { \c_novalue_tl }
		{
			\keys_set:nv { non-decimal-units } { l_ndu_options_#1_tl } 
		}

		% set keys provided by command
		\IfValueT {#2} { \keys_set:nn { non-decimal-units } { #2 } }

		\int_if_exist:cF { g_ndu_variable_#3_int } {
			\int_zero_new:c { g_ndu_variable_#3_int }
		}

		\int_zero_new:N \l__ndu_operand_int

		\bool_if:nTF
		{
			% TODO hacky, but works
			\str_if_eq_p:nV {#4} \c__ndu_plus_tl ||
			\str_if_eq_p:nV {#4} \c__ndu_minus_tl ||
			\tl_if_eq_p:NN {#4} \c__ndu_plus_tl ||
			\tl_if_eq_p:NN {#4} \c__ndu_minus_tl
		}
		{
			% plus or minus means we use the representation of the provided value
			\seq_set_split:Nnn \l_tmpb_seq { . } { #5 }
			\ndu_seq_to_repr:NccN
				\l__ndu_operand_int
				{ l_ndu_group_#1_seq }
				{ l_ndu_base_unit_#1_tl }
				\l_tmpb_seq
		}
		{
			% otherwise (multiplication/division) we use the number provided directly
			\int_set:Nn \l__ndu_operand_int { #5 }
		}

		\int_gset:cn { g_ndu_variable_#3_int } {
			\int_use:c { g_ndu_variable_#3_int }
			#4
			\l__ndu_operand_int
		}
	\group_end:
}

\NewDocumentCommand \nduResult { m o m } {
	\group_begin:
		% set keys for unit group
		\tl_if_eq:cnF { l_ndu_options_#1_tl } { \c_novalue_tl }
		{
			\keys_set:nv { non-decimal-units } { l_ndu_options_#1_tl } 
		}

		% set keys provided by command
		\IfValueT {#2} { \keys_set:nn { non-decimal-units } { #2 } }

		\int_if_exist:cF { g_ndu_variable_#3_int } {
			\int_zero_new:c { g_ndu_variable_#3_int }
		}

		\tl_clear_new:N \l__ndu_result_tl

		\ndu_repr_to_seq:Ncccc
			\l_tmpb_seq
			{ l_ndu_group_#1_seq }
			{ l_ndu_base_unit_#1_tl }
			{ g_ndu_variable_#3_int }
			{ l_ndu_base_unit_#1_tl }

		\bool_if:NTF \l_ndu_aligned_bool
		{
			\ndu_format_value_aligned:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpb_seq
				\l_ndu_cell_width_dim
		}
		{
			\ndu_format_values:NcNN
				\l__ndu_result_tl
				{ l_ndu_group_#1_seq }
				\l_tmpb_seq
				\l_ndu_segment_separator_tl
		}

		% output
		\tl_use:N \l__ndu_result_tl
	\group_end:
}

\NewDocumentCommand \nduHeader { m o } {
	\group_begin:
		% set keys for unit group
		\tl_if_eq:cnF { l_ndu_options_#1_tl } { \c_novalue_tl }
		{
			\keys_set:nv { non-decimal-units } { l_ndu_options_#1_tl } 
		}

		% set keys provided by command
		\IfValueT {#2} { \keys_set:nn { non-decimal-units } { #2 } }

		% build boxes
		\seq_set_eq:Nc \l_tmpa_seq { l_ndu_group_#1_seq }
		\seq_map_indexed_inline:Nn \l_tmpa_seq
		{
			\box_clear_new:c { l__ndu_cell_ \int_to_alph:n {##1} _box }
			\hbox_set_to_wd:cnn
				{ l__ndu_cell_ \int_to_alph:n {##1} _box }
				{ \l_ndu_cell_width_dim }
				{ \hfill \tl_use:c { l_ndu_symbol_ ##2 _tl } }
			\tl_put_right:Nn \l__ndu_result_tl { \box_use:c { l__ndu_cell_ \int_to_alph:n {##1} _box } }

			% stop when we hit the desired unit depth
			\tl_set:Nn \l_tmpa_tl {##2}
			\tl_if_eq:NNT \l_tmpa_tl \l_ndu_unit_depth_tl
			{
				\seq_map_break:
			}
		}

		% output
		\tl_use:N \l__ndu_result_tl
	\group_end:
}

\NewDocumentCommand \nduSymbol { m } {
	\tl_use:c { l_ndu_symbol_#1_tl }
}

\msg_new:nnnn
{ non-decimal-units } { missing-factor }
{ No ~ conversion ~ factor ~ exists ~ between ~ #1 ~ and ~ #2 }
{ You ~ will ~ need ~ to ~ add ~ it ~ when ~ creating ~ the ~ base ~ unit ~ or ~ via ~ nduKeys. }

\NewDocumentCommand \nduFactor { m m } {
	\int_if_exist:cF { l_ndu_factor_#1_#2_int } {
		\msg_error:nnnn { non-decimal-units } { missing-factor } { #1 } { #2 }
	}
	\int_use:c { l_ndu_factor_#1_#2_int }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Setup
% 

\keys_define:nn { non-decimal-units / options }
{
	british	 					.code:n 		= { \input{non-decimal-units.british} } ,
	danish	 					.code:n 		= { \input{non-decimal-units.danish} } ,
	german	 					.code:n 		= { \input{non-decimal-units.german} } ,
}

\IfFormatAtLeastTF { 2022-06-01 } {
    \ProcessKeyOptions [ non-decimal-units / options ]
}{
    \RequirePackage { l3keys2e }
    \ProcessKeysOptions { non-decimal-units / options }
}